local Services = {
	Players = game:GetService("Players"),
	RunService = game:GetService("RunService"),
	UserInputService = game:GetService("UserInputService"),
	TweenService = game:GetService("TweenService")
}

local Cache = (function()
	local localPlayer = Services.Players.LocalPlayer
	return {
		LocalPlayer = localPlayer,
		Mouse = localPlayer:GetMouse(),
		Camera = workspace.CurrentCamera,
		PlayerGui = localPlayer:WaitForChild("PlayerGui")
	}
end)()

local CONFIG = {
	BoxColor = Color3.fromRGB(255, 255, 255),
	BoxThickness = 0.5,
	Enabled = false,
	EnableTeamCheck = false,
	ShowEnemyOnly = false,
	ShowAlliedOnly = false,
	UseTeamColors = false,
	UseActualTeamColors = true,
	EnemyBoxColor = Color3.fromRGB(255, 0, 0),
	AlliedBoxColor = Color3.fromRGB(0, 255, 0),
	NoTeamColor = Color3.fromRGB(255, 255, 255),
	ShowGradient = false,
	GradientColor1 = Color3.fromRGB(255, 86, 0),
	GradientColor2 = Color3.fromRGB(255, 0, 128),
	GradientTransparency = 0.7,
	GradientRotation = 90,
	EnableGradientAnimation = false,
	GradientAnimationSpeed = 1,
	Mode = "Player",
	EnableNPCBox = false,
	NPCBoxColor = Color3.fromRGB(255, 0, 0),
	BossBoxColor = Color3.fromRGB(255, 165, 0),
	UseNPCColors = false,
	EnableTagFilter = true,
	AggressiveNPCDetection = false
}

local EspStorage = {
	Boxes = {},
	TrackedNPCs = {},
	GradientConnection = nil,
	RotationOffset = 0,
	MainScreenGui = nil,
	ScanConnection = nil
}

local NPCTags = {
	"NPC", "Npc", "npc", "Enemy", "enemy", "Enemies", "enemies",
	"Hostile", "hostile", "Bad", "bad", "BadGuy", "badguy",
	"Foe", "foe", "Opponent", "opponent", "Bot", "bot", "Bots", "bots",
	"Mob", "mob", "Mobs", "mobs", "Monster", "monster", "Monsters", "monsters",
	"Zombie", "zombie", "Zombies", "zombies", "Creature", "creature",
	"Animal", "animal", "Beast", "beast", "Villain", "villain",
	"Boss", "boss", "MiniBoss", "miniboss", "Guard", "guard",
	"Guardian", "guardian", "Soldier", "soldier", "Warrior", "warrior",
	"Fighter", "fighter", "Target", "target", "Dummy", "dummy",
}

local function initializeScreenGui()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "BoxESP"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.IgnoreGuiInset = true
	screenGui.DisplayOrder = 999
	screenGui.Parent = Cache.PlayerGui
	EspStorage.MainScreenGui = screenGui
	return screenGui
end

local TeamSystem = {}

function TeamSystem.getTeamsService()
	local teamsService = game:FindService("Teams")
	if teamsService and #teamsService:GetTeams() > 0 then
		return teamsService, "TeamsService"
	end
	
	local replicatedStorage = game:GetService("ReplicatedStorage")
	local teamsFolder = replicatedStorage:FindFirstChild("Teams") 
		or replicatedStorage:FindFirstChild("TeamData")
		or replicatedStorage:FindFirstChild("TeamSystem")
	if teamsFolder then
		return teamsFolder, "ReplicatedStorage"
	end
	
	local workspaceTeams = workspace:FindFirstChild("Teams")
		or workspace:FindFirstChild("TeamData")
	if workspaceTeams then
		return workspaceTeams, "Workspace"
	end
	
	pcall(function()
		local serverStorage = game:GetService("ServerStorage")
		local serverTeams = serverStorage:FindFirstChild("Teams")
		if serverTeams then
			return serverTeams, "ServerStorage"
		end
	end)
	
	return nil, "None"
end

function TeamSystem.getPlayerTeam(targetPlayer)
	if not targetPlayer then return nil end
	
	if targetPlayer.Team then
		return {
			Name = targetPlayer.Team.Name,
			TeamColor = targetPlayer.Team.TeamColor,
			Instance = targetPlayer.Team
		}
	end
	
	if targetPlayer.TeamColor and targetPlayer.TeamColor ~= BrickColor.new("White") then
		return {
			Name = targetPlayer.TeamColor.Name,
			TeamColor = targetPlayer.TeamColor,
			Instance = nil
		}
	end
	
	local teamAttribute = targetPlayer:GetAttribute("Team") 
		or targetPlayer:GetAttribute("TeamName")
		or targetPlayer:GetAttribute("PlayerTeam")
	if teamAttribute then
		return {
			Name = tostring(teamAttribute),
			TeamColor = nil,
			Instance = nil
		}
	end
	
	local teamValue = targetPlayer:FindFirstChild("Team")
		or targetPlayer:FindFirstChild("TeamValue")
		or targetPlayer:FindFirstChild("PlayerTeam")
	if teamValue then
		if teamValue:IsA("StringValue") or teamValue:IsA("IntValue") then
			return {
				Name = tostring(teamValue.Value),
				TeamColor = nil,
				Instance = nil
			}
		end
		if teamValue:IsA("ObjectValue") and teamValue.Value then
			return {
				Name = teamValue.Value.Name,
				TeamColor = nil,
				Instance = teamValue.Value
			}
		end
	end
	
	local leaderstats = targetPlayer:FindFirstChild("leaderstats")
	if leaderstats then
		local teamStat = leaderstats:FindFirstChild("Team")
			or leaderstats:FindFirstChild("Faction")
			or leaderstats:FindFirstChild("Side")
		if teamStat then
			return {
				Name = tostring(teamStat.Value),
				TeamColor = nil,
				Instance = nil
			}
		end
	end
	
	local character = targetPlayer.Character
	if character then
		local charTeam = character:GetAttribute("Team")
			or character:GetAttribute("TeamName")
		if charTeam then
			return {
				Name = tostring(charTeam),
				TeamColor = nil,
				Instance = nil
			}
		end
		
		local humanoid = character:FindFirstChild("Humanoid")
		if humanoid then
			local humTeam = humanoid:GetAttribute("Team")
			if humTeam then
				return {
					Name = tostring(humTeam),
					TeamColor = nil,
					Instance = nil
				}
			end
		end
	end
	
	return nil
end

function TeamSystem.isSameTeam(player1, player2)
	if not player1 or not player2 then return false end
	if player1 == player2 then return true end
	
	local team1 = TeamSystem.getPlayerTeam(player1)
	local team2 = TeamSystem.getPlayerTeam(player2)
	
	if not team1 and not team2 then
		return true
	end
	
	if not team1 or not team2 then
		return false
	end
	
	if team1.Instance and team2.Instance then
		return team1.Instance == team2.Instance
	end
	
	if team1.TeamColor and team2.TeamColor then
		return team1.TeamColor == team2.TeamColor
	end
	
	return team1.Name == team2.Name
end

function TeamSystem.hasTeamSystem()
	local teamsService, location = TeamSystem.getTeamsService()
	if teamsService and location == "TeamsService" then
		return true
	end
	
	for _, player in pairs(Services.Players:GetPlayers()) do
		if TeamSystem.getPlayerTeam(player) then
			return true
		end
	end
	
	return false
end

function TeamSystem.getPlayerTeamColor(targetPlayer)
	local team = TeamSystem.getPlayerTeam(targetPlayer)
	if not team then return nil end
	
	if team.TeamColor then
		return team.TeamColor.Color
	end
	
	if team.Instance and team.Instance:IsA("Team") then
		return team.Instance.TeamColor.Color
	end
	
	return nil
end

local NPCSystem = {}

function NPCSystem.isPlayer(character)
	if not character or not character:IsA("Model") then return false end
	if character == Cache.LocalPlayer.Character then return true end
	local player = Services.Players:GetPlayerFromCharacter(character)
	return player ~= nil
end

function NPCSystem.isNPC(character)
	if not character or not character:IsA("Model") then return false end
	if NPCSystem.isPlayer(character) then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local head = character:FindFirstChild("Head")
	local hrp = character:FindFirstChild("HumanoidRootPart")
	
	if not humanoid or not head or not hrp or humanoid.Health <= 0 then return false end
	
	if CONFIG.AggressiveNPCDetection then 
		return true
	end
	
	if not CONFIG.EnableTagFilter then
		return true
	end
	
	local charName = character.Name:lower()
	for _, tag in pairs(NPCTags) do
		if charName:find(tag:lower(), 1, true) then return true end
	end
	
	local npcFolders = {"NPCs", "Enemies", "Bots", "Mobs", "Targets", "Enemy", "Hostile",
		"Monsters", "Zombies", "Creatures", "Characters", "Spawns", "EnemySpawns", "NPCSpawns", "Bosses"}
	
	for _, folderName in pairs(npcFolders) do
		local folder = workspace:FindFirstChild(folderName)
		if folder and character:IsDescendantOf(folder) then return true end
	end
	
	local npcIndicators = {"NPC", "IsNPC", "IsEnemy", "Hostile"}
	for _, indicator in pairs(npcIndicators) do
		local val = character:FindFirstChild(indicator)
		if val and val:IsA("BoolValue") and val.Value == true then return true end
	end
	
	return false
end

function NPCSystem.isBoss(character)
	if not character then return false end
	
	local charName = character.Name:lower()
	if charName:find("boss") or charName:find("miniboss") or charName:find("leader") then
		return true
	end
	
	if character:GetAttribute("IsBoss") == true then
		return true
	end
	
	return false
end

function NPCSystem.findNPCsRecursive(parent)
	local foundNPCs = {}
	for _, instance in pairs(parent:GetDescendants()) do
		if NPCSystem.isNPC(instance) then
			table.insert(foundNPCs, instance)
		end
	end
	return foundNPCs
end

local Utils = {}

function Utils.isEnemy(targetPlayer)
	if not targetPlayer then return true end
	if not targetPlayer.Character then return true end
	
	if not TeamSystem.hasTeamSystem() then
		return true
	end
	
	return not TeamSystem.isSameTeam(Cache.LocalPlayer, targetPlayer)
end

function Utils.shouldShowPlayer(targetPlayer)
	if not CONFIG.EnableTeamCheck then return true end
	
	local isEnemyPlayer = Utils.isEnemy(targetPlayer)
	
	if CONFIG.ShowEnemyOnly and not isEnemyPlayer then
		return false
	end
	
	if CONFIG.ShowAlliedOnly and isEnemyPlayer then
		return false
	end
	
	return true
end

function Utils.getBoxColor(targetPlayer)
	if not CONFIG.UseTeamColors then
		return CONFIG.BoxColor
	end
	
	if CONFIG.UseActualTeamColors then
		local teamColor = TeamSystem.getPlayerTeamColor(targetPlayer)
		return teamColor or CONFIG.NoTeamColor
	else
		local isEnemyPlayer = Utils.isEnemy(targetPlayer)
		return isEnemyPlayer and CONFIG.EnemyBoxColor or CONFIG.AlliedBoxColor
	end
end

function Utils.getNPCBoxColor(npcCharacter)
	if CONFIG.UseNPCColors then
		if NPCSystem.isBoss(npcCharacter) then
			return CONFIG.BossBoxColor
		else
			return CONFIG.NPCBoxColor
		end
	end
	return CONFIG.NPCBoxColor
end

function Utils.getViewportSize()
	local camera = Cache.Camera or workspace.CurrentCamera
	if camera then
		return camera.ViewportSize
	end
	return Vector2.new(1920, 1080)
end

function Utils.isMobile()
	return Services.UserInputService.TouchEnabled 
		and not Services.UserInputService.KeyboardEnabled
end

local GradientManager = {}

function GradientManager.start()
	GradientManager.stop()
	
	if not CONFIG.EnableGradientAnimation then return end
	
	EspStorage.RotationOffset = 0
	
	EspStorage.GradientConnection = Services.RunService.RenderStepped:Connect(function(deltaTime)
		if not CONFIG.EnableGradientAnimation then
			GradientManager.stop()
			return
		end
		
		EspStorage.RotationOffset = (EspStorage.RotationOffset + deltaTime * CONFIG.GradientAnimationSpeed * 100) % 360
		
		for _, espData in pairs(EspStorage.Boxes) do
			if espData and espData.UIGradient then
				espData.UIGradient.Rotation = (CONFIG.GradientRotation + EspStorage.RotationOffset) % 360
			end
		end
	end)
end

function GradientManager.stop()
	if EspStorage.GradientConnection then
		EspStorage.GradientConnection:Disconnect()
		EspStorage.GradientConnection = nil
	end
	
	for _, espData in pairs(EspStorage.Boxes) do
		if espData and espData.UIGradient then
			espData.UIGradient.Rotation = CONFIG.GradientRotation
		end
	end
end

function GradientManager.updateAll()
	for _, espData in pairs(EspStorage.Boxes) do
		if espData and espData.UIGradient then
			espData.UIGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.000, CONFIG.GradientColor1),
				ColorSequenceKeypoint.new(1.000, CONFIG.GradientColor2)
			}
			if espData.BoxGradient then
				espData.BoxGradient.BackgroundTransparency = CONFIG.GradientTransparency
			end
		end
	end
end

local BoxManager = {}

function BoxManager.updateAllThickness()
	for _, espData in pairs(EspStorage.Boxes) do
		if espData and espData.UIStroke then
			espData.UIStroke.Thickness = CONFIG.BoxThickness
		end
	end
end

function BoxManager.create(targetPlayer)
	if EspStorage.Boxes[targetPlayer] then return end
	
	local boxFrame = Instance.new("Frame")
	boxFrame.Name = "Box_" .. targetPlayer.Name
	boxFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	boxFrame.BackgroundTransparency = 1
	boxFrame.BorderSizePixel = 0
	boxFrame.Parent = EspStorage.MainScreenGui
	
	local uiStroke = Instance.new("UIStroke")
	uiStroke.Thickness = CONFIG.BoxThickness
	uiStroke.Color = CONFIG.BoxColor
	uiStroke.LineJoinMode = Enum.LineJoinMode.Miter
	uiStroke.Parent = boxFrame
	
	local gradientFrame = Instance.new("Frame")
	gradientFrame.Name = "BoxGradient"
	gradientFrame.BorderSizePixel = 0
	gradientFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	gradientFrame.Size = UDim2.new(1, 0, 1, 0)
	gradientFrame.BackgroundTransparency = CONFIG.GradientTransparency
	gradientFrame.Visible = CONFIG.ShowGradient
	gradientFrame.Parent = boxFrame
	
	local uiGradient = Instance.new("UIGradient")
	uiGradient.Rotation = CONFIG.GradientRotation
	uiGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0.000, CONFIG.GradientColor1),
		ColorSequenceKeypoint.new(1.000, CONFIG.GradientColor2)
	}
	uiGradient.Parent = gradientFrame
	
	EspStorage.Boxes[targetPlayer] = {
		Box = boxFrame,
		UIStroke = uiStroke,
		BoxGradient = gradientFrame,
		UIGradient = uiGradient,
		IsNPC = false
	}
	
	return EspStorage.Boxes[targetPlayer]
end

function BoxManager.createNPC(npcCharacter)
	if EspStorage.Boxes[npcCharacter] then return end
	
	local boxFrame = Instance.new("Frame")
	boxFrame.Name = "NPCBox_" .. npcCharacter.Name
	boxFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	boxFrame.BackgroundTransparency = 1
	boxFrame.BorderSizePixel = 0
	boxFrame.Parent = EspStorage.MainScreenGui
	
	local uiStroke = Instance.new("UIStroke")
	uiStroke.Thickness = CONFIG.BoxThickness
	uiStroke.Color = CONFIG.NPCBoxColor
	uiStroke.LineJoinMode = Enum.LineJoinMode.Miter
	uiStroke.Parent = boxFrame
	
	local gradientFrame = Instance.new("Frame")
	gradientFrame.Name = "BoxGradient"
	gradientFrame.BorderSizePixel = 0
	gradientFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	gradientFrame.Size = UDim2.new(1, 0, 1, 0)
	gradientFrame.BackgroundTransparency = CONFIG.GradientTransparency
	gradientFrame.Visible = CONFIG.ShowGradient
	gradientFrame.Parent = boxFrame
	
	local uiGradient = Instance.new("UIGradient")
	uiGradient.Rotation = CONFIG.GradientRotation
	uiGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0.000, CONFIG.GradientColor1),
		ColorSequenceKeypoint.new(1.000, CONFIG.GradientColor2)
	}
	uiGradient.Parent = gradientFrame
	
	EspStorage.Boxes[npcCharacter] = {
		Box = boxFrame,
		UIStroke = uiStroke,
		BoxGradient = gradientFrame,
		UIGradient = uiGradient,
		IsNPC = true
	}
	
	return EspStorage.Boxes[npcCharacter]
end

function BoxManager.update(targetPlayer, espData)
	if not espData or not espData.Box then return end
	
	-- Phân biệt giữa Player và NPC
	local character
	if espData.IsNPC then
		character = targetPlayer  -- Nếu là NPC, targetPlayer đã là character
	else
		character = targetPlayer.Character or targetPlayer  -- Nếu là Player
	end
	
	if not character or character.Parent == nil then
		espData.Box.Visible = false
		return
	end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then
		espData.Box.Visible = false
		return
	end
	
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid or humanoid.Health <= 0 then
		espData.Box.Visible = false
		return
	end
	
	-- Chỉ kiểm tra team nếu là Player
	if not espData.IsNPC and CONFIG.EnableTeamCheck then
		local isEnemyPlayer = Utils.isEnemy(targetPlayer)
		
		if CONFIG.ShowEnemyOnly and not isEnemyPlayer then
			espData.Box.Visible = false
			return
		end
		
		if CONFIG.ShowAlliedOnly and isEnemyPlayer then
			espData.Box.Visible = false
			return
		end
	end
	
	local charSize = character:GetExtentsSize()
	local boxHeight = charSize.Y * 0.8
	local boxWidth = charSize.X * 0.8
	
	local camera = Cache.Camera or workspace.CurrentCamera
	local viewportSize = Utils.getViewportSize()
	
	local headTop = humanoidRootPart.Position + Vector3.new(0, charSize.Y / 2, 0)
	local feetBottom = humanoidRootPart.Position - Vector3.new(0, charSize.Y / 1.4, 0)
	
	local headScreenPos, headOnScreen = camera:WorldToViewportPoint(headTop)
	local feetScreenPos, feetOnScreen = camera:WorldToViewportPoint(feetBottom)
	
	local screenX = (headScreenPos.X + feetScreenPos.X) / 2
	local screenYTop = headScreenPos.Y
	
	local displayHeight = math.abs(feetScreenPos.Y - headScreenPos.Y)
	local displayWidth = displayHeight * (boxWidth / boxHeight)
	
	espData.Box.Size = UDim2.new(0, displayWidth, 0, displayHeight)
	espData.Box.Position = UDim2.new(0, screenX - displayWidth / 2, 0, screenYTop)
	
	if espData.UIStroke then
		espData.UIStroke.Thickness = CONFIG.BoxThickness
	end
	
	if espData.BoxGradient then
		espData.BoxGradient.Visible = CONFIG.ShowGradient
		espData.BoxGradient.BackgroundTransparency = CONFIG.GradientTransparency
	end
	
	if espData.UIGradient then
		espData.UIGradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.000, CONFIG.GradientColor1),
			ColorSequenceKeypoint.new(1.000, CONFIG.GradientColor2)
		}
		if not CONFIG.EnableGradientAnimation then
			espData.UIGradient.Rotation = CONFIG.GradientRotation
		end
	end
	
	local boxColor
	if espData.IsNPC then
		boxColor = Utils.getNPCBoxColor(character)
	else
		boxColor = Utils.getBoxColor(targetPlayer)
	end
	
	if espData.UIStroke then
		espData.UIStroke.Color = boxColor
	end
	
	local isInFront = headScreenPos.Z > 0
	local isInViewportX = screenX > -displayWidth and screenX < viewportSize.X + displayWidth
	local isInViewportY = screenYTop > -displayHeight and screenYTop < viewportSize.Y + displayHeight
	
	espData.Box.Visible = isInFront and isInViewportX and isInViewportY
end


function BoxManager.remove(targetPlayer)
	local espData = EspStorage.Boxes[targetPlayer]
	if espData then
		if espData.Box then
			espData.Box:Destroy()
		end
		EspStorage.Boxes[targetPlayer] = nil
	end
end

function BoxManager.updateAll()
	for targetPlayer, espData in pairs(EspStorage.Boxes) do
		if targetPlayer and targetPlayer.Parent and espData then
			if targetPlayer == Cache.LocalPlayer then
				continue
			end
			
			if espData.IsNPC then
				if CONFIG.Enabled and (CONFIG.Mode == "NPC" or CONFIG.Mode == "Both") then
					BoxManager.update(targetPlayer, espData)
				else
					espData.Box.Visible = false
				end
			else
				if CONFIG.Enabled and (CONFIG.Mode == "Player" or CONFIG.Mode == "Both") and Utils.shouldShowPlayer(targetPlayer) then
					BoxManager.update(targetPlayer, espData)
				else
					espData.Box.Visible = false
				end
			end
		else
			BoxManager.remove(targetPlayer)
		end
	end
end

local NPCMode = {}

function NPCMode.scanForNPCs()
	local foundNPCs = NPCSystem.findNPCsRecursive(workspace)
	
	local foundSet = {}
	for _, npc in pairs(foundNPCs) do
		foundSet[npc] = true
	end
	
	for npc in pairs(EspStorage.TrackedNPCs) do
		if not foundSet[npc] or not npc.Parent then
			BoxManager.remove(npc)
			EspStorage.TrackedNPCs[npc] = nil
		end
	end
	
	for _, npc in pairs(foundNPCs) do
		if not EspStorage.TrackedNPCs[npc] then
			EspStorage.TrackedNPCs[npc] = true
			BoxManager.createNPC(npc)
		end
	end
end

function NPCMode.initialize()
	NPCMode.scanForNPCs()
	
	if not EspStorage.ScanConnection then
		EspStorage.ScanConnection = Services.RunService.Heartbeat:Connect(function()
			if CONFIG.Enabled and (CONFIG.Mode == "NPC" or CONFIG.Mode == "Both") then
				NPCMode.scanForNPCs()
			end
		end)
	end
end

function NPCMode.cleanup()
	local npcsToRemove = {}
	for target in pairs(EspStorage.Boxes) do
		if target:IsA("Model") and NPCSystem.isNPC(target) then
			table.insert(npcsToRemove, target)
		end
	end
	
	for _, npc in pairs(npcsToRemove) do
		BoxManager.remove(npc)
	end
	
	EspStorage.TrackedNPCs = {}
end

local EventHandler = {}

function EventHandler.onPlayerAdded(newPlayer)
	if newPlayer ~= Cache.LocalPlayer then
		if Utils.shouldShowPlayer(newPlayer) then
			task.wait(0.5)
			if CONFIG.Mode == "Player" or CONFIG.Mode == "Both" then
				BoxManager.create(newPlayer)
			end
		end
	end
end

function EventHandler.onPlayerRemoving(leavingPlayer)
	BoxManager.remove(leavingPlayer)
end

local function initialize()
	initializeScreenGui()
	
	Services.Players.PlayerAdded:Connect(EventHandler.onPlayerAdded)
	Services.Players.PlayerRemoving:Connect(EventHandler.onPlayerRemoving)
	
	for _, otherPlayer in pairs(Services.Players:GetPlayers()) do
		if otherPlayer ~= Cache.LocalPlayer then
			EventHandler.onPlayerAdded(otherPlayer)
		end
	end
	
	NPCMode.initialize()
	
	Services.RunService.RenderStepped:Connect(function()
		BoxManager.updateAll()
	end)
	
	workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		Cache.Camera = workspace.CurrentCamera
	end)
end

initialize()

local BoxAPIModule = {}

function BoxAPIModule:UpdateConfig(newConfig)
	for key, value in pairs(newConfig) do
		if CONFIG[key] ~= nil then
			CONFIG[key] = value
		end
	end
	
	if newConfig.EnableGradientAnimation ~= nil then
		if newConfig.EnableGradientAnimation then
			GradientManager.start()
		else
			GradientManager.stop()
		end
	end
end

function BoxAPIModule:GetConfig()
	return CONFIG
end

function BoxAPIModule:Toggle(state)
	CONFIG.Enabled = state
end

function BoxAPIModule:SetMode(mode)
	if mode == "Player" or mode == "NPC" or mode == "Both" then
		CONFIG.Mode = mode
	end
end

function BoxAPIModule:GetMode()
	return CONFIG.Mode
end

function BoxAPIModule:Destroy()
	GradientManager.stop()
	
	if EspStorage.ScanConnection then
		EspStorage.ScanConnection:Disconnect()
		EspStorage.ScanConnection = nil
	end
	
	for targetPlayer in pairs(EspStorage.Boxes) do
		BoxManager.remove(targetPlayer)
	end
	
	if EspStorage.MainScreenGui then
		EspStorage.MainScreenGui:Destroy()
	end
end

function BoxAPIModule:GetTrackedTargets()
	local targets = {}
	for target in pairs(EspStorage.Boxes) do
		table.insert(targets, target)
	end
	return targets
end

BoxAPIModule.getTeamsService = TeamSystem.getTeamsService
BoxAPIModule.isSameTeam = TeamSystem.isSameTeam
BoxAPIModule.getPlayerTeam = TeamSystem.getPlayerTeam

return BoxAPIModule
